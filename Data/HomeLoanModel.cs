// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using BFGBlazor.Data;
//
//    var homeLoans = HomeLoans.FromJson(jsonString);

namespace BFGBlazor.Data
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class HomeLoans
    {
        [Key]
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("abbr")]
        public string Abbr { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("notes")]
        public string Notes { get; set; }

        [JsonProperty("type")]
        public HomeLoanType Type { get; set; }

        [JsonProperty("lender")]
        public Lender[] Lender { get; set; }

        [JsonProperty("residential")]
        public Residential Residential { get; set; }

        [JsonProperty("gateway")]
        public Gateway[] Gateway { get; set; }

        [JsonProperty("fee")]
        public Fee[] Fee { get; set; }

        [JsonProperty("isActive")]
        public bool IsActive { get; set; }

        [JsonProperty("comparisonRateEstimate")]
        public ComparisonRateEstimate[] ComparisonRateEstimate { get; set; }

        [JsonProperty("maximumBorrowingEstimate")]
        public MaximumBorrowingEstimate[] MaximumBorrowingEstimate { get; set; }
    }

    public partial class ComparisonRateEstimate
    {
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public Guid Id { get; set; }
        [JsonProperty("comparisonRate")]
        public double ComparisonRate { get; set; }
    }

    public partial class Fee
    {
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public Guid Id { get; set; }
        [JsonProperty("type")]
        public FeeType Type { get; set; }

        [JsonProperty("name")]
        public Name Name { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("value")]
        public double Value { get; set; }
    }

    public partial class Gateway
    {
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public Guid Id { get; set; }
        [JsonProperty("type")]
        public GatewayType Type { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class Lender
    {
        [Key]
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("abbr")]
        public string Abbr { get; set; }

        [JsonProperty("turnaround")]
        public long Turnaround { get; set; }
    }

    public partial class MaximumBorrowingEstimate
    {
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public Guid Id { get; set; }
        [JsonProperty("maximumBorrowing")]
        public double MaximumBorrowing { get; set; }
    }

    public partial class Residential
    {
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public Guid Id { get; set; }
        [JsonProperty("type")]
        public ResidentialType Type { get; set; }

        [JsonProperty("rateType")]
        public RateType RateType { get; set; }

        [JsonProperty("repaymentType")]
        public RepaymentType RepaymentType { get; set; }

        [JsonProperty("propertyUse")]
        public PropertyUse PropertyUse { get; set; }

        [JsonProperty("baseInitialRate")]
        public double BaseInitialRate { get; set; }

        [JsonProperty("initialRate")]
        public double InitialRate { get; set; }

        [JsonProperty("discountInitialRate")]
        public double DiscountInitialRate { get; set; }

        [JsonProperty("baseRevertRate")]
        public double BaseRevertRate { get; set; }

        [JsonProperty("revertRate")]
        public double RevertRate { get; set; }

        [JsonProperty("discountRevertRate")]
        public double DiscountRevertRate { get; set; }

        [JsonProperty("lvrMin")]
        public double LvrMin { get; set; }

        [JsonProperty("lvrMax")]
        public long LvrMax { get; set; }

        [JsonProperty("loanMin")]
        public double LoanMin { get; set; }

        [JsonProperty("loanMax")]
        public double LoanMax { get; set; }

        [JsonProperty("termMax")]
        public long TermMax { get; set; }

        [JsonProperty("fixedTerm")]
        public long FixedTerm { get; set; }

        [JsonProperty("introTerm")]
        public long IntroTerm { get; set; }

        [JsonProperty("ioMaxPeriod")]
        public long IoMaxPeriod { get; set; }

        [JsonProperty("ioMinPeriod")]
        public long IoMinPeriod { get; set; }

        [JsonProperty("proPackDiscount")]
        public long ProPackDiscount { get; set; }

        [JsonProperty("lep")]
        public long Lep { get; set; }

        [JsonProperty("proPack")]
        public AdditionalRepayments ProPack { get; set; }

        [JsonProperty("smsf")]
        public AdditionalRepayments Smsf { get; set; }

        [JsonProperty("creditImpaired")]
        public AdditionalRepayments CreditImpaired { get; set; }

        [JsonProperty("whiteLabel")]
        public AdditionalRepayments WhiteLabel { get; set; }

        [JsonProperty("lineOfCredit")]
        public AdditionalRepayments LineOfCredit { get; set; }

        [JsonProperty("construction")]
        public AdditionalRepayments Construction { get; set; }

        [JsonProperty("lmiCapitalization")]
        public AdditionalRepayments LmiCapitalization { get; set; }

        [JsonProperty("lmiRequiredOver")]
        public double LmiRequiredOver { get; set; }

        [JsonProperty("redrawFacility")]
        public AdditionalRepayments RedrawFacility { get; set; }

        [JsonProperty("additionalRepayments")]
        public AdditionalRepayments AdditionalRepayments { get; set; }

        [JsonProperty("offset")]
        public AdditionalRepayments Offset { get; set; }

        [JsonProperty("splitLoan")]
        public AdditionalRepayments SplitLoan { get; set; }
    }

    public enum Name { ConstructionFee, ContractPreparationFee, Fee };

    public enum FeeType { Application, Legal, Monthly, Other, RateLock, Settlement, Upfront, Valuation, Yearly };

    public enum GatewayType { ELodge, NextGen, Simpology };

    public enum AdditionalRepayments { No, NotEssential, Yes };

    public enum PropertyUse { OwnerOccupied, ResidentialInvestment };

    public enum RateType { Fixed, Variable };

    public enum RepaymentType { Io, Ioa, Pi };

    public enum ResidentialType { FullDoc };

    public enum HomeLoanType { Residential };

    public partial class HomeLoans
    {
        public static HomeLoans[] FromJson(string json) => JsonConvert.DeserializeObject<HomeLoans[]>(json, BFGBlazor.Data.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this HomeLoans[] self) => JsonConvert.SerializeObject(self, BFGBlazor.Data.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                NameConverter.Singleton,
                FeeTypeConverter.Singleton,
                GatewayTypeConverter.Singleton,
                AdditionalRepaymentsConverter.Singleton,
                PropertyUseConverter.Singleton,
                RateTypeConverter.Singleton,
                RepaymentTypeConverter.Singleton,
                ResidentialTypeConverter.Singleton,
                HomeLoanTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Construction Fee":
                    return Name.ConstructionFee;
                case "Contract Preparation Fee ":
                    return Name.ContractPreparationFee;
                case "Fee":
                    return Name.Fee;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.ConstructionFee:
                    serializer.Serialize(writer, "Construction Fee");
                    return;
                case Name.ContractPreparationFee:
                    serializer.Serialize(writer, "Contract Preparation Fee ");
                    return;
                case Name.Fee:
                    serializer.Serialize(writer, "Fee");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class FeeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeeType) || t == typeof(FeeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "APPLICATION":
                    return FeeType.Application;
                case "LEGAL":
                    return FeeType.Legal;
                case "MONTHLY":
                    return FeeType.Monthly;
                case "OTHER":
                    return FeeType.Other;
                case "RATE_LOCK":
                    return FeeType.RateLock;
                case "SETTLEMENT":
                    return FeeType.Settlement;
                case "UPFRONT":
                    return FeeType.Upfront;
                case "VALUATION":
                    return FeeType.Valuation;
                case "YEARLY":
                    return FeeType.Yearly;
            }
            throw new Exception("Cannot unmarshal type FeeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FeeType)untypedValue;
            switch (value)
            {
                case FeeType.Application:
                    serializer.Serialize(writer, "APPLICATION");
                    return;
                case FeeType.Legal:
                    serializer.Serialize(writer, "LEGAL");
                    return;
                case FeeType.Monthly:
                    serializer.Serialize(writer, "MONTHLY");
                    return;
                case FeeType.Other:
                    serializer.Serialize(writer, "OTHER");
                    return;
                case FeeType.RateLock:
                    serializer.Serialize(writer, "RATE_LOCK");
                    return;
                case FeeType.Settlement:
                    serializer.Serialize(writer, "SETTLEMENT");
                    return;
                case FeeType.Upfront:
                    serializer.Serialize(writer, "UPFRONT");
                    return;
                case FeeType.Valuation:
                    serializer.Serialize(writer, "VALUATION");
                    return;
                case FeeType.Yearly:
                    serializer.Serialize(writer, "YEARLY");
                    return;
            }
            throw new Exception("Cannot marshal type FeeType");
        }

        public static readonly FeeTypeConverter Singleton = new FeeTypeConverter();
    }

    internal class GatewayTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GatewayType) || t == typeof(GatewayType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "E_LODGE":
                    return GatewayType.ELodge;
                case "NEXT_GEN":
                    return GatewayType.NextGen;
                case "SIMPOLOGY":
                    return GatewayType.Simpology;
            }
            throw new Exception("Cannot unmarshal type GatewayType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GatewayType)untypedValue;
            switch (value)
            {
                case GatewayType.ELodge:
                    serializer.Serialize(writer, "E_LODGE");
                    return;
                case GatewayType.NextGen:
                    serializer.Serialize(writer, "NEXT_GEN");
                    return;
                case GatewayType.Simpology:
                    serializer.Serialize(writer, "SIMPOLOGY");
                    return;
            }
            throw new Exception("Cannot marshal type GatewayType");
        }

        public static readonly GatewayTypeConverter Singleton = new GatewayTypeConverter();
    }

    internal class AdditionalRepaymentsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AdditionalRepayments) || t == typeof(AdditionalRepayments?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NO":
                    return AdditionalRepayments.No;
                case "NOT_ESSENTIAL":
                    return AdditionalRepayments.NotEssential;
                case "YES":
                    return AdditionalRepayments.Yes;
            }
            throw new Exception("Cannot unmarshal type AdditionalRepayments");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AdditionalRepayments)untypedValue;
            switch (value)
            {
                case AdditionalRepayments.No:
                    serializer.Serialize(writer, "NO");
                    return;
                case AdditionalRepayments.NotEssential:
                    serializer.Serialize(writer, "NOT_ESSENTIAL");
                    return;
                case AdditionalRepayments.Yes:
                    serializer.Serialize(writer, "YES");
                    return;
            }
            throw new Exception("Cannot marshal type AdditionalRepayments");
        }

        public static readonly AdditionalRepaymentsConverter Singleton = new AdditionalRepaymentsConverter();
    }

    internal class PropertyUseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PropertyUse) || t == typeof(PropertyUse?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "OWNER_OCCUPIED":
                    return PropertyUse.OwnerOccupied;
                case "RESIDENTIAL_INVESTMENT":
                    return PropertyUse.ResidentialInvestment;
            }
            throw new Exception("Cannot unmarshal type PropertyUse");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PropertyUse)untypedValue;
            switch (value)
            {
                case PropertyUse.OwnerOccupied:
                    serializer.Serialize(writer, "OWNER_OCCUPIED");
                    return;
                case PropertyUse.ResidentialInvestment:
                    serializer.Serialize(writer, "RESIDENTIAL_INVESTMENT");
                    return;
            }
            throw new Exception("Cannot marshal type PropertyUse");
        }

        public static readonly PropertyUseConverter Singleton = new PropertyUseConverter();
    }

    internal class RateTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RateType) || t == typeof(RateType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FIXED":
                    return RateType.Fixed;
                case "VARIABLE":
                    return RateType.Variable;
            }
            throw new Exception("Cannot unmarshal type RateType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RateType)untypedValue;
            switch (value)
            {
                case RateType.Fixed:
                    serializer.Serialize(writer, "FIXED");
                    return;
                case RateType.Variable:
                    serializer.Serialize(writer, "VARIABLE");
                    return;
            }
            throw new Exception("Cannot marshal type RateType");
        }

        public static readonly RateTypeConverter Singleton = new RateTypeConverter();
    }

    internal class RepaymentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RepaymentType) || t == typeof(RepaymentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "IO":
                    return RepaymentType.Io;
                case "IOA":
                    return RepaymentType.Ioa;
                case "PI":
                    return RepaymentType.Pi;
            }
            throw new Exception("Cannot unmarshal type RepaymentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RepaymentType)untypedValue;
            switch (value)
            {
                case RepaymentType.Io:
                    serializer.Serialize(writer, "IO");
                    return;
                case RepaymentType.Ioa:
                    serializer.Serialize(writer, "IOA");
                    return;
                case RepaymentType.Pi:
                    serializer.Serialize(writer, "PI");
                    return;
            }
            throw new Exception("Cannot marshal type RepaymentType");
        }

        public static readonly RepaymentTypeConverter Singleton = new RepaymentTypeConverter();
    }

    internal class ResidentialTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ResidentialType) || t == typeof(ResidentialType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "FULL_DOC")
            {
                return ResidentialType.FullDoc;
            }
            throw new Exception("Cannot unmarshal type ResidentialType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ResidentialType)untypedValue;
            if (value == ResidentialType.FullDoc)
            {
                serializer.Serialize(writer, "FULL_DOC");
                return;
            }
            throw new Exception("Cannot marshal type ResidentialType");
        }

        public static readonly ResidentialTypeConverter Singleton = new ResidentialTypeConverter();
    }

    internal class HomeLoanTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HomeLoanType) || t == typeof(HomeLoanType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "RESIDENTIAL")
            {
                return HomeLoanType.Residential;
            }
            throw new Exception("Cannot unmarshal type HomeLoanType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HomeLoanType)untypedValue;
            if (value == HomeLoanType.Residential)
            {
                serializer.Serialize(writer, "RESIDENTIAL");
                return;
            }
            throw new Exception("Cannot marshal type HomeLoanType");
        }

        public static readonly HomeLoanTypeConverter Singleton = new HomeLoanTypeConverter();
    }
}
